import Foundationstruct Coordinate {    var x: Int    var y: Int}struct Line {    var coordinates: (Coordinate, Coordinate)}enum mode {    case idling    case working}struct Figure {    var startPoint: Coordinate    var secondPoint: Coordinate    var thirdPoint: Coordinate    var endPoint: Coordinate    var sklPosition: Coordinate}    func coordinatesIntoLines(_ figure: Figure, _ taskLines: [Line]) -> [Line] {        let SKLFirstLine = Line(coordinates: (Coordinate(x: figure.startPoint.x + figure.sklPosition.x, y: figure.startPoint.y + figure.sklPosition.y),                                              Coordinate (x: figure.secondPoint.x + figure.sklPosition.x, y: figure.secondPoint.y + figure.sklPosition.y)))            let SKLSecondLine = Line(coordinates: (Coordinate(x: figure.secondPoint.x + figure.sklPosition.x, y: figure.secondPoint.y + figure.sklPosition.y),                                               Coordinate(x: figure.thirdPoint.x + figure.sklPosition.x, y: figure.thirdPoint.y + figure.sklPosition.y)))            let SKLThirdLine = Line(coordinates: (Coordinate(x: figure.thirdPoint.x + figure.sklPosition.x, y: figure.thirdPoint.y + figure.sklPosition.y),                                              Coordinate(x: figure.endPoint.x + figure.sklPosition.x, y: figure.endPoint.y + figure.sklPosition.y)))            let SKLFourthLine = Line(coordinates: (Coordinate(x: figure.endPoint.x + figure.sklPosition.x, y: figure.endPoint.y + figure.sklPosition.y),                                               Coordinate(x: figure.startPoint.x + figure.sklPosition.x, y: figure.startPoint.y + figure.sklPosition.y)))               let figureLines: [Line] = [SKLFirstLine, SKLSecondLine, SKLThirdLine, SKLFourthLine]                let newArray = taskLines + figureLines            for element in newArray {            print(element.coordinates.0.x, element.coordinates.0.y, element.coordinates.1.x, element.coordinates.1.y)        }        print("\n")        return newArray}func deleting(_ arrayOfLines: [Line]) -> [Line] {    var xCoord: [Line] = []    var yCoord: [Line] = []    var result: [Line] = []    for line in arrayOfLines {        if (line.coordinates.0.x != line.coordinates.1.x) && (line.coordinates.0.y != line.coordinates.1.y) {            result.append(line)     //уникальные отрезки        }                if line.coordinates.0.x == line.coordinates.1.x {            xCoord.append(line)    // фильтрация если отрезки совпадают по х для поиска накладывающихся отрезков        }                if line.coordinates.0.y == line.coordinates.1.y{            yCoord.append(line)   // фильтрация если отрезки совпадают по y для поиска накладывающихся отрезков        }    }       for i in 0..<xCoord.count - 1 {        let sum1 = xCoord[i].coordinates.0.y + xCoord[i].coordinates.1.y        for j in 1..<xCoord.count - 1 {        let sum2 = xCoord[j].coordinates.0.y + xCoord[j].coordinates.1.y            if (xCoord[i].coordinates.0.x == xCoord[j].coordinates.0.x) { // условие срабатывает не полностью                if (sum2 > sum1) && (!result.contains(where: xCoord[j])) {             //не получается через метод contains сделать проверку лежат ли уже такие координаты в массиве                    result.append(xCoord[j])                } else if (sum2 < sum1) {                    result.append(xCoord[i])                }            }        }    }    for i in 0..<yCoord.count - 1 {        let sum1 = yCoord[i].coordinates.0.x + yCoord[i].coordinates.1.x        for j in 1..<yCoord.count - 1 {        let sum2 = yCoord[j].coordinates.0.x + yCoord[j].coordinates.1.x            if (yCoord[i].coordinates.0.y == yCoord[j].coordinates.0.y) { // условие не срабатывает                if (sum2 > sum1) {                    result.append(yCoord[j])                } else if (sum2 < sum1) {                    result.append(yCoord[i])                }            }        }    }    return result}func working(_ array: [Line]) {    var routes: [Line] = array    routes.sorted(by: {($0.coordinates.0.x + $0.coordinates.1.x) + ($0.coordinates.0.y + $0.coordinates.1.y) < ($1.coordinates.0.x + $1.coordinates.1.x) + ($1.coordinates.0.y + $1.coordinates.1.y)})   //в моем понимании нужно сделать сортировку от меньшего к большему из координат отрезков    routes.reversed() //перевернуть чтобы идти от большего к меньшему        var finalLines: [Line] = []    finalLines.append(routes[0]) // самые большие координаты отрезка в любом случае нужно добавлять    for element in finalLines {        print(element.coordinates.0.x, element.coordinates.0.y, element.coordinates.1.x, element.coordinates.1.y)    }    for index in 0..<routes.count - 1 {        let routeArray = routes[index]        let leftSum = routeArray.coordinates.0.x + routeArray.coordinates.0.y        let rightSum = routeArray.coordinates.1.x + routeArray.coordinates.1.y        switch index % 2 {        case 1:  // если отрезок по индексу нечетный то меняем местами х1 у1 и х2 у2            if (leftSum > rightSum) {                let subArray = Line(coordinates: (Coordinate(x: routeArray.coordinates.1.x, y: routeArray.coordinates.1.y),                                    Coordinate(x: routeArray.coordinates.0.x, y: routeArray.coordinates.0.y)))                finalLines.append(subArray)            } else {                finalLines.append(routeArray) //добавляем отрезок без изменений            }            break        case 0:            if leftSum < rightSum { // если отрезок по индексу четный то меняем местами х1 у1 и х2 у2                let subArray = Line(coordinates: (Coordinate(x: routeArray.coordinates.1.x, y: routeArray.coordinates.1.y),                                    Coordinate(x: routeArray.coordinates.0.x, y: routeArray.coordinates.0.y)))                finalLines.append(subArray)            } else {                finalLines.append(routeArray) //добавляем отрезок без изменений            }            break        default:            break        }    }        }let figure1 = Figure(startPoint: Coordinate(x: 0, y: 0), secondPoint: Coordinate(x: 1500, y: 0), thirdPoint: Coordinate(x: 1500, y: 1000), endPoint: Coordinate(x: 0, y: 1485), sklPosition: Coordinate(x: 500, y: 15))let arrayOfLinesExample: [Line] = [Line(coordinates: (Coordinate(x: 500, y: 0), Coordinate(x: 500, y: 3210))),                                   Line(coordinates: (Coordinate(x: 0, y: 15), Coordinate(x: 6000, y: 15))),                                   Line(coordinates: (Coordinate(x: 2000, y: 0), Coordinate(x: 2000, y: 3210))),                                   Line(coordinates: (Coordinate(x: 500, y: 1515), Coordinate(x: 2000, y: 1515))),                                    ]let arrayOfLines = coordinatesIntoLines(figure1, arrayOfLinesExample)working(deleting(arrayOfLines))//задание не решено, не работает сортировка отрезков и работа станка, не добавлены режимы холостого и рабочего хода